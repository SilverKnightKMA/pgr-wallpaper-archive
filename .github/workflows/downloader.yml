name: PGR Wallpapers Downloader

on:
  schedule:
    - cron: '0 0 * * 0'
  workflow_dispatch:
    inputs:
      max_images:
        description: 'Maximum number of images allowed before triggering downloader.'
        required: false
        default: 10000

jobs:
  scrape-and-download:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      has_new_images: ${{ steps.check_new.outputs.has_new }}
      release_tag: ${{ steps.set_tag.outputs.tag }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v6
        with:
          ref: main
          fetch-depth: 1

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 18
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      - name: Install ImageMagick
        run: sudo apt-get update && sudo apt-get install -y imagemagick

      - name: Ensure branches exist
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          REMOTE_URL="https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"

          for BRANCH_NAME in \
            "$(node -e "const c=require('./config.json'); console.log(c.wallpapersBranch || 'wallpapers')")" \
            "$(node -e "const c=require('./config.json'); console.log(c.previewBranch || 'preview')")"; do
            if git ls-remote --exit-code origin "$BRANCH_NAME" >/dev/null 2>&1; then
              echo "âœ… Branch $BRANCH_NAME already exists."
            else
              echo "ðŸ†• Creating new orphan branch: $BRANCH_NAME"
              INIT_DIR=$(mktemp -d)
              git -C "$INIT_DIR" init
              git -C "$INIT_DIR" remote add origin "$REMOTE_URL"
              git -C "$INIT_DIR" checkout -b "$BRANCH_NAME"
              git -C "$INIT_DIR" commit --allow-empty -m "Initialize branch $BRANCH_NAME"
              git -C "$INIT_DIR" push origin "$BRANCH_NAME"
              rm -rf "$INIT_DIR"
              echo "  âœ… Branch $BRANCH_NAME created."
            fi
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Load existing image manifest for comparison
        run: |
          mkdir -p data
          SERVERS=$(node -e "const c=require('./config.json'); c.servers.forEach(s => console.log(s.id))")
          WALLPAPERS_BRANCH=$(node -e "const c=require('./config.json'); console.log(c.wallpapersBranch || 'wallpapers')")

          # Build per-server .existing_images from manifest (not from git ls-tree)
          # This avoids inflating existingImages.size with filenames from other servers
          if [ -f "data/manifest.json" ]; then
            while IFS= read -r id; do
              mkdir -p "branches/$id"
              python3 -c "
          import json, sys
          with open('data/manifest.json') as f:
              m = json.load(f)
          sid = sys.argv[1]
          if sid in m and 'wallpapers' in m[sid]:
              for w in m[sid]['wallpapers']:
                  fn = w.get('filename')
                  if fn and w.get('status') == 'success':
                      print(fn)
          " "$id" > "branches/$id/.existing_images"
            done <<< "$SERVERS"
          else
            while IFS= read -r id; do
              mkdir -p "branches/$id"
            done <<< "$SERVERS"
          fi
          
      - name: Scrape Links
        env:
          MAX_IMAGES: ${{ inputs.max_images }}
        run: node src/scraper.js

      - name: Retry broken links from previous runs
        run: |
          SERVERS=$(node -e "const c=require('./config.json'); c.servers.forEach(s => console.log(s.id))")
          while IFS= read -r id; do
            failed_file="Wallpapers/failed/${id}.txt"
            txt_file="Wallpapers/images_url/${id}.txt"
            if [ -f "$failed_file" ] && [ -s "$failed_file" ]; then
              echo "ðŸ”„ Retrying failed URLs for $id"
              # Append failed URLs to the download list if not already present
              while IFS= read -r url; do
                if ! grep -qxF "$url" "$txt_file" 2>/dev/null; then
                  echo "$url" >> "$txt_file"
                fi
              done < "$failed_file"
            fi
          done <<< "$SERVERS"

      - name: Download Wallpapers
        shell: pwsh
        run: ./src/downloader.ps1

      - name: Move images into images/ subdirectory
        run: |
          SERVERS=$(node -e "const c=require('./config.json'); c.servers.forEach(s => console.log(s.id))")
          while IFS= read -r id; do
            if [ -d "branches/$id" ]; then
              mkdir -p "branches/$id/images"
              find "branches/$id" -maxdepth 1 -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.webp' \) -exec mv {} "branches/$id/images/" \;
            fi
          done <<< "$SERVERS"

      - name: Generate Thumbnails
        run: |
          SERVERS=$(node -e "const c=require('./config.json'); c.servers.forEach(s => console.log(s.id))")
          while IFS= read -r id; do
            THUMB_WIDTH=$(node -e "const c=require('./config.json'); console.log(c.settings.thumbnailWidth || 400)")
            if [ -d "branches/$id/images" ]; then
              bash src/generate_thumbnails.sh "branches/$id/images" "$THUMB_WIDTH"
              # Move thumbnails to branch-level thumbnails/ dir
              if [ -d "branches/$id/images/thumbnails" ]; then
                mkdir -p "branches/$id/thumbnails"
                find "branches/$id/images/thumbnails" -maxdepth 1 -type f -exec mv {} "branches/$id/thumbnails/" \;
                rmdir "branches/$id/images/thumbnails" 2>/dev/null || true
              fi
            fi
          done <<< "$SERVERS"

      - name: Check for new images
        id: check_new
        run: |
          new_count=0
          SERVERS=$(node -e "const c=require('./config.json'); c.servers.forEach(s => console.log(s.id))")
          while IFS= read -r id; do
            txt="Wallpapers/images_url/${id}.txt"
            if [ -f "$txt" ] && [ -s "$txt" ]; then
              count=$(wc -l < "$txt")
              new_count=$((new_count + count))
            fi
          done <<< "$SERVERS"
          echo "New images found: $new_count"
          if [ "$new_count" -gt 0 ]; then
            echo "has_new=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_new=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Set release tag
        id: set_tag
        if: steps.check_new.outputs.has_new == 'true'
        run: |
          TAG="wallpapers-$(date -u +%Y%m%d-%H%M%S)"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          # Derive ISO timestamp from tag name (wallpapers-YYYYMMDD-HHMMSS)
          TAG_TS=$(echo "$TAG" | sed 's/wallpapers-\([0-9]\{4\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)-\([0-9]\{2\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)/\1-\2-\3T\4:\5:\6Z/')
          echo "timestamp=$TAG_TS" >> "$GITHUB_OUTPUT"
          echo "Release tag: $TAG â†’ $TAG_TS"

      - name: Build manifest and push to wallpapers/preview branches
        if: steps.check_new.outputs.has_new == 'true'
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          REPO_DIR="$(pwd)"
          REMOTE_URL="https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          WALLPAPERS_BRANCH=$(node -e "const c=require('./config.json'); console.log(c.wallpapersBranch || 'wallpapers')")
          PREVIEW_BRANCH=$(node -e "const c=require('./config.json'); console.log(c.previewBranch || 'preview')")
          TIMESTAMP="${RELEASE_TAG_TS}"

          # --- Wallpapers branch (all images at root, flat structure) ---
          WP_DIR="$(mktemp -d)/repo"
          git init "$WP_DIR"
          git -C "$WP_DIR" remote add origin "$REMOTE_URL"
          if git ls-remote --exit-code origin "$WALLPAPERS_BRANCH" >/dev/null 2>&1; then
            git -C "$WP_DIR" fetch origin "$WALLPAPERS_BRANCH" --depth=1
            git -C "$WP_DIR" checkout -b "$WALLPAPERS_BRANCH" "origin/$WALLPAPERS_BRANCH"
          else
            git -C "$WP_DIR" checkout -b "$WALLPAPERS_BRANCH"
          fi

          # Install Git LFS for files >100MB
          git -C "$WP_DIR" lfs install --local

          # --- Preview branch (thumbnails + READMEs, per-server dirs) ---
          PV_DIR="$(mktemp -d)/repo"
          git init "$PV_DIR"
          git -C "$PV_DIR" remote add origin "$REMOTE_URL"
          if git ls-remote --exit-code origin "$PREVIEW_BRANCH" >/dev/null 2>&1; then
            git -C "$PV_DIR" fetch origin "$PREVIEW_BRANCH" --depth=1
            git -C "$PV_DIR" checkout -b "$PREVIEW_BRANCH" "origin/$PREVIEW_BRANCH"
          else
            git -C "$PV_DIR" checkout -b "$PREVIEW_BRANCH"
          fi

          # Load existing manifest from main branch data dir if available
          MANIFEST="{}"
          if [ -f "$REPO_DIR/data/manifest.json" ]; then
            MANIFEST=$(cat "$REPO_DIR/data/manifest.json")
          fi

          # Build manifest JSON with detailed wallpaper info
          mkdir -p "$REPO_DIR/data"

          SERVERS=$(node -e "const c=require('./config.json'); c.servers.forEach(s => console.log(s.id))")
          SERVER_ARGS=""
          while IFS= read -r id; do
            SERVER_ARGS="$SERVER_ARGS $id"
          done <<< "$SERVERS"

          # Copy new images to wallpapers branch root first (so manifest can read sizes)
          while IFS= read -r id; do
            BRANCH_DIR="$REPO_DIR/branches/$id"
            IMG_DIR="$BRANCH_DIR/images"

            # Count new images
            IMAGE_COUNT=0
            if [ -d "$IMG_DIR" ]; then
              IMAGE_COUNT=$(find "$IMG_DIR" -maxdepth 1 -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.webp' \) 2>/dev/null | wc -l)
            fi

            if [ "$IMAGE_COUNT" -eq 0 ]; then
              echo "â­ï¸ No new images for $id, skipping."
              continue
            fi

            echo "ðŸ“‚ Processing server: $id ($IMAGE_COUNT new images)"

            # Copy images to wallpapers branch root (flat structure)
            find "$IMG_DIR" -maxdepth 1 -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.webp' \) -exec cp {} "$WP_DIR/" \;

            # Track files >100MB for Git LFS
            find "$IMG_DIR" -maxdepth 1 -type f \( -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.png' -o -iname '*.webp' \) -size +100M | while read -r bigfile; do
              echo "  âš ï¸ Large file detected (>100MB): $(basename "$bigfile"), tracking with Git LFS"
              git -C "$WP_DIR" lfs track "$(basename "$bigfile")"
            done

            # Copy thumbnails to preview branch (per-server dirs preserved)
            mkdir -p "$PV_DIR/$id/thumbnails"
            if [ -d "$BRANCH_DIR/thumbnails" ]; then
              find "$BRANCH_DIR/thumbnails" -maxdepth 1 -type f -exec cp {} "$PV_DIR/$id/thumbnails/" \;
            fi
          done <<< "$SERVERS"

          # Use build_manifest.py to build detailed manifest (with size info)
          MANIFEST=$(printf '%s' "$MANIFEST" | python3 "$REPO_DIR/src/build_manifest.py" "$WP_DIR" "$REPO_DIR" "$TIMESTAMP" $SERVER_ARGS)

          # Save manifest to main branch data dir (needed by branch README generation)
          echo "$MANIFEST" > "$REPO_DIR/data/manifest.json"

          # Generate per-server READMEs on preview branch (always, not just when new images)
          while IFS= read -r id; do
            MANIFEST_PATH="$REPO_DIR/data/manifest.json" BRANCH_DIR="$WP_DIR" BRANCH_README_OUTPUT="$PV_DIR/$id/README.md" FAILED_FILE="$REPO_DIR/Wallpapers/failed/${id}.txt" node "$REPO_DIR/src/generate_readme.js" branch "$id"
          done <<< "$SERVERS"

          # --- Push wallpapers branch ---
          git -C "$WP_DIR" config user.name "github-actions[bot]"
          git -C "$WP_DIR" config user.email "github-actions[bot]@users.noreply.github.com"
          git -C "$WP_DIR" add -A
          if git -C "$WP_DIR" diff --cached --quiet; then
            echo "  No changes for $WALLPAPERS_BRANCH."
          else
            git -C "$WP_DIR" commit -m "Auto-sync: Update wallpapers"
            git -C "$WP_DIR" push origin HEAD:"$WALLPAPERS_BRANCH" --force-with-lease
            echo "  âœ… Pushed to $WALLPAPERS_BRANCH"
          fi
          rm -rf "$(dirname "$WP_DIR")"

          # --- Push preview branch ---
          git -C "$PV_DIR" config user.name "github-actions[bot]"
          git -C "$PV_DIR" config user.email "github-actions[bot]@users.noreply.github.com"
          git -C "$PV_DIR" add -A
          if git -C "$PV_DIR" diff --cached --quiet; then
            echo "  No changes for $PREVIEW_BRANCH."
          else
            git -C "$PV_DIR" commit -m "Auto-sync: Update previews"
            git -C "$PV_DIR" push origin HEAD:"$PREVIEW_BRANCH" --force-with-lease
            echo "  âœ… Pushed to $PREVIEW_BRANCH"
          fi
          rm -rf "$(dirname "$PV_DIR")"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_TAG_TS: ${{ steps.set_tag.outputs.timestamp }}

      - name: Update main README and manifest
        if: steps.check_new.outputs.has_new == 'true'
        run: |
          MANIFEST_PATH="$(pwd)/data/manifest.json" node src/generate_readme.js main
          # Vendor PGR favicon locally if not already present
          if [ ! -f docs/favicon.png ]; then
            curl -sL -o docs/favicon.png "https://cdnstatic.kurogame.net/h5_manage_dist/pgr_website2.0/favicon.png" || true
          fi
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add README.md data/manifest.json
          [ -f docs/favicon.png ] && git add docs/favicon.png
          if git diff --cached --quiet; then
            echo "No README changes."
          else
            git commit -m "Auto-sync: Update main README and manifest"
            git push
          fi

      - name: Collect release assets
        if: steps.check_new.outputs.has_new == 'true'
        id: release_notes
        run: |
          WALLPAPERS_BRANCH=$(node -e "const c=require('./config.json'); console.log(c.wallpapersBranch || 'wallpapers')")
          PREVIEW_BRANCH=$(node -e "const c=require('./config.json'); console.log(c.previewBranch || 'preview')")
          # Derive release timestamp from tag name (wallpapers-YYYYMMDD-HHMMSS â†’ YYYY-MM-DD HH:MM:SS UTC)
          RELEASE_TIMESTAMP=$(echo "$RELEASE_TAG" | sed 's/wallpapers-\([0-9]\{4\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)-\([0-9]\{2\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)/\1-\2-\3 \4:\5:\6 UTC/')
          mkdir -p release_assets release_staging
          RELEASE_BODY="ðŸ“… **Release Time:** ${RELEASE_TIMESTAMP}\n\n"
          HAS_FILES=false
          SERVERS=$(node -e "const c=require('./config.json'); c.servers.forEach(s => console.log(s.id + '|' + s.name))")
          while IFS='|' read -r id name; do
            txt="Wallpapers/images_url/${id}.txt"
            if [ -f "$txt" ] && [ -s "$txt" ]; then
              BRANCH_DIR="branches/$id"
              FILE_COUNT=0
              while IFS= read -r url; do
                raw_filename=$(basename "$url")
                # Decode percent-encoded filename
                decoded_filename=$(python3 -c "import urllib.parse, sys; print(urllib.parse.unquote(sys.argv[1]))" "$raw_filename")
                if [ -f "$BRANCH_DIR/images/$decoded_filename" ]; then
                  FILE_COUNT=$((FILE_COUNT + 1))
                elif [ -f "$BRANCH_DIR/images/$raw_filename" ]; then
                  FILE_COUNT=$((FILE_COUNT + 1))
                fi
              done < "$txt"

              # Copy new images into a per-server folder for the zip
              if [ $FILE_COUNT -gt 0 ]; then
                HAS_FILES=true
                mkdir -p "release_staging/$id"
                while IFS= read -r url; do
                  raw_filename=$(basename "$url")
                  decoded_filename=$(python3 -c "import urllib.parse, sys; print(urllib.parse.unquote(sys.argv[1]))" "$raw_filename")
                  if [ -f "$BRANCH_DIR/images/$decoded_filename" ]; then
                    cp "$BRANCH_DIR/images/$decoded_filename" "release_staging/$id/$decoded_filename"
                  elif [ -f "$BRANCH_DIR/images/$raw_filename" ]; then
                    cp "$BRANCH_DIR/images/$raw_filename" "release_staging/$id/$raw_filename"
                  fi
                done < "$txt"

                # Build release notes section for this server â€” only file list & preview
                RELEASE_BODY="${RELEASE_BODY}<details><summary>ðŸ“‹ File list & preview ${name} (${FILE_COUNT} new)</summary>\n\n"
                RELEASE_BODY="${RELEASE_BODY}| Preview | Filename | Download | Status |\n"
                RELEASE_BODY="${RELEASE_BODY}|---------|----------|----------|--------|\n"
                while IFS= read -r url; do
                  raw_filename=$(basename "$url")
                  decoded_filename=$(python3 -c "import urllib.parse, sys; print(urllib.parse.unquote(sys.argv[1]))" "$raw_filename")
                  encoded_filename=$(python3 -c "import urllib.parse, sys; print(urllib.parse.quote(sys.argv[1], safe='%'))" "$decoded_filename")
                  thumb_url="https://raw.githubusercontent.com/${GITHUB_REPOSITORY}/${PREVIEW_BRANCH}/${id}/thumbnails/${encoded_filename}"
                  download_url="https://github.com/${GITHUB_REPOSITORY}/raw/${WALLPAPERS_BRANCH}/${encoded_filename}"
                  RELEASE_BODY="${RELEASE_BODY}| <img src=\"${thumb_url}\" width=\"100\"> | \`${decoded_filename}\` | [Download](${download_url}) | âœ… |\n"
                done < "$txt"
                RELEASE_BODY="${RELEASE_BODY}\n</details>\n\n---\n\n"
              fi
            fi
          done <<< "$SERVERS"

          # Create zip file(s) for release, ensuring each is under 2GB (GitHub release asset limit)
          MAX_ZIP_BYTES=$((1900 * 1024 * 1024))  # 1.9 GB safety margin below GitHub's 2 GB limit
          if [ "$HAS_FILES" = true ]; then
            TOTAL_SIZE=$(du -sb release_staging | cut -f1)
            echo "ðŸ“¦ Total staging size: $(numfmt --to=iec $TOTAL_SIZE)"

            if [ "$TOTAL_SIZE" -lt "$MAX_ZIP_BYTES" ]; then
              # All files fit in a single zip
              cd release_staging
              zip -r "../release_assets/${RELEASE_TAG}.zip" .
              cd ..
              echo "  âœ… Created single zip"
            else
              # Split into per-server zips to stay under 2GB
              echo "  âš ï¸ Total size exceeds 1.9 GB, creating per-server zips"
              PART=1
              for server_dir in release_staging/*/; do
                [ -d "$server_dir" ] || continue
                server_id=$(basename "$server_dir")
                SERVER_SIZE=$(du -sb "$server_dir" | cut -f1)
                echo "  ðŸ“‚ $server_id: $(numfmt --to=iec $SERVER_SIZE)"

                if [ "$SERVER_SIZE" -lt "$MAX_ZIP_BYTES" ]; then
                  cd release_staging
                  zip -r "../release_assets/${RELEASE_TAG}-part${PART}.zip" "$server_id"
                  cd ..
                else
                  # Single server exceeds limit â€” split files into multiple zips
                  echo "    âš ï¸ Server $server_id exceeds 1.9 GB, splitting into multiple zips"
                  CURRENT_SIZE=0
                  SUB=1
                  FILE_LIST=""
                  cd release_staging
                  while IFS= read -r -d '' file; do
                    FSIZE=$(stat -c%s "$file")
                    if [ "$CURRENT_SIZE" -gt 0 ] && [ $((CURRENT_SIZE + FSIZE)) -ge "$MAX_ZIP_BYTES" ]; then
                      zip "../release_assets/${RELEASE_TAG}-part${PART}-${SUB}.zip" $FILE_LIST
                      SUB=$((SUB + 1))
                      CURRENT_SIZE=0
                      FILE_LIST=""
                    fi
                    FILE_LIST="$FILE_LIST \"$file\""
                    CURRENT_SIZE=$((CURRENT_SIZE + FSIZE))
                  done < <(find "$server_id" -type f -print0)
                  if [ -n "$FILE_LIST" ]; then
                    eval zip "../release_assets/${RELEASE_TAG}-part${PART}-${SUB}.zip" $FILE_LIST
                  fi
                  cd ..
                fi
                PART=$((PART + 1))
              done
              echo "  âœ… Created $((PART - 1)) zip part(s)"
            fi
          fi

          # Write release body to file
          echo -e "$RELEASE_BODY" > release_notes.md

          # Output whether we have files to release
          echo "has_files=$HAS_FILES" >> "$GITHUB_OUTPUT"
        env:
          RELEASE_TAG: ${{ steps.set_tag.outputs.tag }}

      - name: Create GitHub Release
        if: steps.check_new.outputs.has_new == 'true' && steps.release_notes.outputs.has_files == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.set_tag.outputs.tag }}
          name: "Wallpapers ${{ steps.set_tag.outputs.tag }}"
          body_path: release_notes.md
          files: release_assets/*.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
